---
title: "SPI Device Driver for Register Access"
subtitle: "UART-to-SPI Command Pipeline for Remote Register Read/Write"
excerpt: "Implementation of an SPI device driver that translates JSON commands received over UART into SPI register read/write operations on target devices via a CAST SPI-to-AHB bridge"
date: 2025-05-08
author: "Myung Guk Lee"
draft: false
series:
  - Device Driver Development
  - Embedded Systems
tags:
  - SPI
  - Device Driver
  - UART
  - CAST
  - AHB Bridge
  - Embedded Systems
categories:
  - Technical Projects
layout: single
---

## Project Overview

Implemented an SPI device driver that bridges UART commands to register-level access on target devices connected via SPI. A host application sends JSON-formatted read/write commands over UART to an ARM Cortex-R5F processor, which parses the command and executes the corresponding SPI transaction through a CAST SPI-to-AHB bridge to reach the target chip. This enables remote register read/write on any SPI-connected device from a PC.

## End-to-End Command Flow

The central design pattern is a **UART → JSON Parser → SPI Driver → Target Device** pipeline:

```
┌──────────┐    UART     ┌──────────────┐    SPI Bus    ┌──────────────┐    AHB Bus   ┌────────┐
│ Host PC  │ ──JSON───→  │ ARM Cortex-  │ ──MOSI/MISO→  │ CAST SPI-to- │ ──────────→  │ Target │
│ (Python) │ ←─JSON───   │ R5F (Driver) │ ←───────────  │ AHB Bridge   │ ←──────────  │ Device │
└──────────┘             └──────────────┘               └──────────────┘              └────────┘
```

**Example — Register Write**:
1. Host sends JSON over UART: `{"cmd": "cast_write", "addr": "0x1000", "data": "0xDEADBEEF"}`
2. CMD task on R5F parses the JSON, extracts address and data
3. SPI driver executes `castspi_single_write(0x1000, 0xDEADBEEF)` — a multi-step SPI transaction
4. CAST bridge translates SPI frames into an AHB write to the target device's register `0x1000`
5. Driver reads status back, sends JSON response over UART to host

**Example — Register Read**:
1. Host sends: `{"cmd": "cast_read", "addr": "0x2000", "delay": 8}`
2. CMD task parses JSON, calls `castspi_single_read(0x2000, 8)`
3. SPI driver sends address, waits for AHB response, receives 32-bit data
4. Driver sends JSON response: `{"status": "ok", "data": "0x12345678"}`

## How SPI Works

SPI (Serial Peripheral Interface) is a synchronous, full-duplex bus with four signals:

- **SCLK** — Clock generated by the master (R5F processor)
- **MOSI** — Master Out, Slave In — data from R5F to the target device
- **MISO** — Master In, Slave Out — data from the target device to R5F
- **CS** (Chip Select) — Active low, selects the target slave device

The master controls the entire transaction. Every SPI transfer is a simultaneous send-and-receive: while the master clocks out command/address bytes on MOSI, the slave clocks out response/status bytes on MISO.

```
        CS  ──┐                                          ┌──
              └──────────────────────────────────────────┘
       SCLK     _   _   _   _   _   _   _   _   _   _
            ___| |_| |_| |_| |_| |_| |_| |_| |_| |_| |___

       MOSI  [  CMD  ][   ADDRESS   ][   DATA OUT   ]
       MISO  [ dummy ][ dummy/status ][   DATA IN    ]
```

Key characteristics relevant to this driver:
- **No built-in protocol** — SPI is just a byte pipe. The slave device defines the command format (opcodes, address layout, dummy cycles)
- **Master-driven** — The slave cannot initiate a transfer. To read data, the master must send clock cycles (often with dummy bytes on MOSI) so the slave can shift data out on MISO
- **Chip Select framing** — Each logical transaction (command + address + data) is framed by asserting/deasserting CS

## CAST SPI-to-AHB Bridge Operations

The CAST bridge translates SPI byte sequences into AHB bus transactions. Each operation is a **multi-frame SPI conversation** — the driver must send specific opcodes in sequence and check status between steps.

### Register Write

```c
void castspi_single_write(uint32_t address, uint32_t data);
```

The driver performs three separate SPI transfers to complete one register write:

```
Transaction 1: Clear status
  CS low → [WRITE_STS 0x90] [status_byte] → CS high

Transaction 2: Verify ready
  CS low → [READ_STS 0x98] → [status_byte on MISO] → CS high
  Check: BUSY == 0

Transaction 3: Write register
  CS low → [WRITE 0x80] [4B addr] [4B data] → CS high

Transaction 4: Verify completion
  CS low → [READ_STS 0x98] → [status_byte on MISO] → CS high
  Check: BUSY == 0, no error bits set
```

### Register Read — Predictable Timing

```c
uint32_t castspi_single_read_predicted_delay(uint32_t address, uint32_t predicted_delay);
```

Used when the AHB response time is **known and consistent**. The driver inserts a fixed number of dummy clock cycles (0, 8, or 16) after sending the address, giving the AHB bus time to fetch the data before the master clocks it out on MISO.

```
CS low → [READ 0x88] [4B addr] [dummy cycles...] [4B data on MISO] → CS high
                                 ^^^^^^^^^^^^^^^^
                                 Master sends dummy bytes on MOSI
                                 while waiting for AHB to respond.
                                 Data appears on MISO after the delay.
```

If the AHB response takes longer than the dummy cycles, the bridge sets `SLOW_ERR` in the status register — the driver must either increase the delay or switch to unpredictable mode.

### Register Read — Unpredictable Timing

```c
uint32_t castspi_single_read_unpredicted_delay(uint32_t address);
```

Used when the AHB response time is **variable or unknown**. Instead of guessing dummy cycles, the driver polls the status register in a loop until `BUSY` clears, then reads data from the bridge's RXD register.

```
Transaction 1: Issue read command
  CS low → [READ 0x88] [4B addr] → CS high

Transaction 2: Poll until ready (repeat until BUSY == 0)
  CS low → [READ_STS 0x98] → [status on MISO] → CS high

Transaction 3: Fetch data
  CS low → [READ_RXD 0xA0] → [4B data on MISO] → CS high
```

This is slower (3+ separate CS transactions) but guarantees correct data regardless of AHB latency.

### Predictable vs. Unpredictable — When to Use Each

- **Predictable**: Registers with fixed AHB latency (e.g., simple control/status registers). Faster — single CS transaction
- **Unpredictable**: Registers behind arbitration, memory controllers, or cross-clock-domain bridges. Slower but safe — polls until data is ready

## Conclusion

The SPI device driver translates high-level JSON commands arriving over UART into low-level SPI bus transactions for register access on target devices. The CAST bridge's multi-step protocol (opcode → address → dummy/poll → data) is abstracted behind simple read/write functions, while the dual timing modes (predictable vs. unpredictable) handle varying AHB response characteristics. The UART-to-SPI pipeline enables remote register access on any SPI-connected chip from a host PC, making development and debugging significantly faster.
